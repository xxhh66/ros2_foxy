大家好，我是永远吃不饱的小胖鱼。这两天在写《动手学ROS2》教程的时候，一会冒出来一个回调函数。



因为担心未来的读者们被回调函数绕晕，小鱼今天就特意把回调函数拎出来说一说。



## 一、小故事-李老三借钱



![图片](assets/640.webp)



小鱼依然讲个小故事来说一说。

李家村有一个兄弟，一个叫李老三、一个叫李老四。李老四是个作家，靠写书赚了不少钱。李老三有天没钱吃饭，找李老四去借钱。

李老三到了李老四家，问李老四能不能借给点钱

老四说行，但是你要等等，我要去银行给你取，你可以在我家等我，也可以先回去，等我取到了打电话给你，让你来拿

李老三心想，我要是在这等着不知道要等到啥时候，不如先回家喂国宝，于是李老三就回去了。

过了一个小时，李老四打电话给李老三了，让李老三去拿钱，李老三就先放下手下的活，过去拿了钱，然后回家继续喂熊猫，到了中午就拿着钱去吃麻辣烫了。



## 二、同步与异步调用

我们把借钱看作一个函数，李老三借钱时的两种选择（原地等待还是回家等通知），分别对应着同步调用和异步调用。

•同步调用：调用者会一直等待函数返回，函数不返回程序就不向下执行，比如李老三一直等着李老四把钱取回来才肯走
•异步调用：调用者调用完成后，不用等待函数返回，可以继续做其他事情，函数的返回会以回调函数（还有其他方式，这里我们只说一种）返回，比如李老三直接回家喂熊猫（做其他事情），电话相当于回调函数

所以同步调用可以理解为没有回调函数，而**异步调用必须要设置回调函数来接收返回值**。

这里有一个重点就是设置回调函数接收返回值，这个就是回调函数最重要的用处之一。

## 三、回调函数

这里我们来讲一讲回调函数，上面说到异步调用需要设置一个回调函数来接收返回值。

大家想一想，平时编写 ROS 和 ROS2 代码时候，在哪里设置了回调函数？

### 3.1 Python 里的回调函数

#### 3.1.1 Python 版本的订阅话题

```python
import rospy
import math
from std_msgs import String

#回调函数输入的应该是 msg
def data_callback(data):
    rospy.loginfo("data=%s",data.data)
    
if __name__ = "__main__"
    rospy.init_node("pylistener",anonymous=True)
    #Subscriber 函数第一个参数是 topic 的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber("test",String,data_callback)
    rospy.spin()


```

`data_callback`就是一个回调函数，当话题 test 中有数据的时候，系统就会帮我们自动调用`data_callback`函数，为什么调用`data_callback`函数呢？

因为我们在`rospy.Subscriber("test",String,data_callback)`是将其设置为了回调函数。

#### 3.1.2 ROS2 版 Python 请求服务



```
def borrow_respoonse_callback(self,response):
    # 打印一下信息
    result = response.result()
    if result.success == True:
        self.get_logger().info("果然是亲弟弟，借到%d,吃麻辣烫去了" % result.money)
    else:
        self.get_logger().info("害，连几块钱都不借,我还是不是他亲了，世态炎凉呀")  
self.borrow_money_client_.call_async(request).add_done_callback(self.borrow_res
```

借钱客户调用异步服务`call_async`之后，使用`add_done_callback`来添加了一个回调函数，用于接收服务端的返回数据。

> 在 Python 中一个函数可以作为一个对象来使用，所以我们可以把函数名 borrow_respoonse_callback 当作入口参数传入 add_done_callback 函数。

### 3.2 C++里的回调函数

#### 3.2.1 比如 C++订阅话题

```c++
#include "ros/ros.h"
#include "std_msgs/String.h"

void callback(const std_msgs::String::ConstPtr& msg)
{
  //do something
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "node_name");
  ros::NodeHandle n;
  ros::Subscriber sub = n.subscribe("topic", 10, callback);
  ros::spin();
  return 0;
}
```

这里也把`callback`作为一个参数传到的`subscribe`中，即设置回调函数，告诉 ROS 系统，当有数据来了，就调用`callback`来处理。

> C++里我们也可以把一个函数名称作为参数传入另外一个函数，对应的概念是函数指针，所谓函数指针就是指向函数的指针

#### 3.2.2 成员函数如何变成回调函数

这里讲一个小知识点，就是把成员函数作为回调函数，传说的 OOP 做法。这里举个栗子，这里获取雷达数据的例子。.h 文件

```c++
class My_Filter {
     public:
        My_Filter();
        //订阅 LaserScan 数据，先转换为 PointCloud2，再转换为 pcl::PointCloud
        void scanCallback_2(const sensor_msgs::LaserScan::ConstPtr& scan);
     private:
        ros::NodeHandle node_;
        //订阅 "/scan"
        ros::Subscriber scan_sub_;
};
```

```c++
#include "laser_fusion/Laser2Cloud.h"
My_Filter::My_Filter(){
    //订阅　"/scan"
    scan_sub_ = node_.subscribe<sensor_msgs::LaserScan> ("scan", 100, &My_Filter::scanCallback_2, this);
}
void My_Filter::scanCallback_2(const sensor_msgs::LaserScan::ConstPtr& scan){
    //do something
}
```



## 四、总结

在 ROS 和 ROS2 中，回调函数的用处非常之多，可以说处处都有回调函数的身影。

相比较同步调用，异步调用更能提升系统的性能，比如李老三顺手把熊猫给喂了。
但回调函数的使用过程中也要注意一些小问题，比如函数的重入，数据的同步等等。