# [4.5.1 自定义服务接口](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_451-自定义服务接口)

帅鱼又来了，上一节小鱼给大家介绍了什么是服务，并且给大家举了李三向李四借钱吃麻辣烫，张三向王二买二手书的例子。作为ROS镇的创造者的我们，肯定要满足村民们的需求。

所以本节小鱼将带你一起，创造一个借钱服务接口和一个买书服务接口。

## [1.服务接口介绍](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_1服务接口介绍)

在4.5到4.6章节中，小鱼介绍了接口和话题接口的概念。那服务接口和话题接口有什么不同呢？

那就要看，话题和服务有什么不同之处了。之前小鱼曾提起过：

- 话题是**发布订阅模型**。主要是单向传输数据，只能由发布者发布，接收者接收（同一话题，发布者接收者都可以有多个）
- 服务是**客户端服务端（请求响应）模型**。由客户端发送请求，服务端处理请求，然后返回处理结果（同一服务，客户端可以由多个，服务端只能有一个）

由以上差别我们可以知道，话题通信是单向的，自定义话题只需要定义**传过去的数据类型**就行，而服务是双向的，所以要定义**一去一回两种数据类型**。

我们来看一下服务的消息接口长什么样子？

服务接口格式：`xxx.srv`

```bash
int64 a
int64 b
---
int64 sum
```

与话题不同的是，srv文件比msg文件中间多出了三个`---`这三个杠杠就是分界线，上方的是客户端发送请求的数据结构定义，下方的是服务端响应结果的数据结构定义。

是不是也很好理解，那如何创建我们自己的服务接口呢？可以参考下面的步骤：

- 新建`srv`文件夹，并在文件夹下新建`xxx.srv`
- 在`xxx.srv`下编写服务接口内容并保存
- 在`CmakeLists.txt`添加依赖和srv文件目录
- 在`package.xml`中添加`xxx.srv`所需的依赖
- 编译功能包即可生成`python`与c++头文件

当然在做上面的步骤之前，我们还需要做一件很重要的事情。就是根据业务需求，确定好请求的数据结构和返回的数据结构。

## [2.创建借钱服务接口](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_2创建借钱服务接口)

我们依然是在`village_interfaces`下创建服务接口。

### [2.1 确认数据结构](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_21-确认数据结构)

开始之前，我们先根据李四的需求来确定数据结构。

上一节中李四对借钱的要求如下：

1. 借钱一定要打欠条，收到欠条才能给钱
2. 每次借钱不能超过自己全部资金的`10%`且一定是整数，也就是说李四假如现在有100块钱，那么最多借出去`100x10%=10`块钱

总结一下就是，李三发送借钱请求的时候一定要有欠条，我们想一下，欠条中应该至少包含两条信息

- 借钱者名字，字符串类型、可以用`string`表示
- 金额，整形，可以用`uint32`表示

那请求的数据结构我们就可以确定下来了，接着确定返回的数据的格式。

既然是借钱，那李四就有可能拒绝，会有借钱失败的情况，所以返回数据应该有这两条信息：

- 是否出借：只有成功和失败两种情况，布尔类型（`bool`）可表示
- 出借金额：无符号整形，可以用`uint32`表示，借钱失败时为0

### [2.2 创建`srv`文件夹及`BorrowMoney.srv`消息文件](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_22-创建srv文件夹及borrowmoneysrv消息文件)

打开VsCode，然后打开`town_ws`，在`village_interfaces`下新建srv文件夹。

> 同样大家可以使用鼠标右击新建，不用输入命令行😜

```shell
cd src/village_interfaces
mkdir srv && cd srv
touch BorrowMoney.srv
```

创建完成后的目录结构

![image-20210811162010736](assets/image-20210811162010736.png)

### [2.3 编写文件内容](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_23-编写文件内容)

既然确定了内容，编写文件就很简单了

```bash
string name
uint32 money
---
bool success
uint32 money
```

### [2.4修改`CMakeLists.txt`](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_24修改cmakeliststxt)

因为在4.6中我们已经添加过依赖`DEPENDENCIES`和`msg`文件了，所以这里我们直接添加一个`srv`即可。

```cmake
find_package(rosidl_default_generators REQUIRED)
rosidl_generate_interfaces(${PROJECT_NAME}
  #---msg---
  "msg/Novel.msg"
  #---srv---
  "srv/BorrowMoney.srv"
  DEPENDENCIES sensor_msgs
 )
```

需要关注的是这一行`"srv/BorrowMoney.srv"`,添加了对应的文件位置。

### [2.5修改`package.xml`](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_25修改packagexml)

在4.6节我们已经添加过了，这里就不用添加了，如果没有加的同学可以再加一次。

```xml
  <build_depend>sensor_msgs</build_depend>
  <build_depend>rosidl_default_generators</build_depend>
  <exec_depend>rosidl_default_runtime</exec_depend>
  <member_of_group>rosidl_interface_packages</member_of_group>
```

### [2.6编译](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_26编译)

在vscode中，使用`Ctrl+Shift+~`打开一个新的终端，在`town_ws`目录下输入：

```shell
colcon build --packages-select village_interfaces
```

![image-20210811163033796](assets/image-20210811163033796.png)

### [2.7测试](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_27测试)

这次测试我们依然使用`ros2 interface`指令进行测试。

之前已经测试过了话题了，这里小鱼就只放一下测试指令和测试结果。

```
source install/setup.bash 
ros2 interface package village_interfaces
ros2 interface show village_interfaces/srv/BorrowMoney
ros2 interface proto village_interfaces/srv/BorrowMoney 
```

> 注意，`ros2 interface proto` 该指令目前只显示出请求部分话题数据

![image-20210816145858746](assets/image-20210816145858746.png)

## [3.创建买书服务接口](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_3创建买书服务接口)

### [3.1 确认数据结构](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_31-确认数据结构)

和创建借钱服务一样，我们先确定王二卖书的数据结构。

上一节中王二对卖书的要求如下：

1. 必须一手交钱，一手交货，爱买不买😎
2. 每次给多少钱卖多少章，每章一块钱，如果手里的存货不足，就继续等待

总结一下，王二提供书的时候，一定要先给钱才行，所以张三只需要给钱就行，服务的请求数据结构如下：

- 买书的钱，无符号整形，`uint32`

那王二返回什么呢？因为王二对应的数量艳娘传奇，所以王二的返回就是n章小说。

一章节的小说我们可以采用`string`来，那n章节的小说该怎么办？办法就是用`string`数组来容纳多个章节。

- 所以王二的返回是一个`string`类型的数组，表示多个章节的书

### [3.2 创建`srv`文件夹及`SellNovel.srv`消息文件](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_32-创建srv文件夹及sellnovelsrv消息文件)

上面我们已经创建了`srv`，这里直接创建`SellNovel.srv`

```
cd src/village_interfaces
cd srv
touch SellNovel.srv
```

创建完成后的目录结构

![image-20210812173303503](assets/image-20210812173303503.png)

### [3.3 编写文件内容](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_33-编写文件内容)

用无符号整形表示`money`大家已经很清楚如何做了，那如何表示小说数组呢？其实只需在类型的后面加上`[]`中括号。

完整内容如下：

```
uint32 money
---
string[] novels
```

请求时给钱，返回即为多章小说。

### [3.4修改`CMakeLists.txt`](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_34修改cmakeliststxt)

在上面的基础上，再添加上一行`"srv/SellNovel.srv"`代码即可：

```
rosidl_generate_interfaces(${PROJECT_NAME}
  #---msg---
  "msg/Novel.msg"
  #---srv---
  "srv/BorrowMoney.srv"
  "srv/SellNovel.srv"
   DEPENDENCIES sensor_msgs
 )
```

### [3.5修改`package.xml`](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_35修改packagexml)

同样的，因为我们已经修改过了，这里就不需要修改了。

### [3.6编译](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_36编译)

在vscode中，使用`Ctrl+Shift+~`打开一个新的终端，在`town_ws`目录下输入：

```shell
cd ~/town_ws
colcon build --packages-select village_interfaces
```

![image-20210811163033796](assets/image-20210811163033796-176708607831329.png)

### [3.7测试](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_37测试)

这次测试我们依然使用`ros2 interface`指令进行测试。

之前已经测试过了话题了，这里小鱼就只放一下测试指令和测试结果。

```
source install/setup.bash 
ros2 interface package village_interfaces
ros2 interface show village_interfaces/srv/SellNovel
ros2 interface proto village_interfaces/srv/SellNovel 
```

> 注意，`ros2 interface proto`该指令目前只显示出请求部分话题数据

![image-20210816150038830](assets/image-20210816150038830.png)

## [4.总结](https://fishros.com/d2lros2foxy/#/chapt4/4.8自定义服务接口?id=_4总结)

本节小鱼带大家创建了用于借钱和买书的服务接口，下一节我们就开始编写代码，完成借钱服务。

# [4.5.2 Python服务通信实现(李三借钱)](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_452-python服务通信实现李三借钱)

大家好，我是小鱼。上节说完如何自定义ROS2的服务接口。

相信你已经迫不及待的想尝试一下编写代码了，让我们一起来动手,让李三成功借钱，吃上麻辣烫吧。

## [1.如何编写一个Python服务](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_1如何编写一个python服务)

开始之前，我们先说一下创建ROS2服务端基本步骤。

首先是服务端：

1. 导入服务接口
2. 创建服务端回调函数
3. 声明并创建服务端
4. 编写回调函数逻辑处理请求

## [2.编写服务端李四代码](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_2编写服务端李四代码)

我们先来创建李四这边的服务端。用VsCode打开我们的`town_ws`工作区。

### [2.1 导入服务接口](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_21-导入服务接口)

我们在上一节中自定义的服务接口这里该怎么使用呢？

需要下面两个步骤：

#### [2.1.1 添加依赖](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_211-添加依赖)

导入依赖是为了能够让我们的代码找到对应的接口。

因为`village_li`是包类型是`ament_python`这里只需要在`package.xml`中加入下面的代码即可：

```
  <depend>village_interfaces</depend>
```

![image-20210816153438400](assets/image-20210816153438400.png)

#### [2.1.2 程序中导入](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_212-程序中导入)

程序中导入也是只需要一行代码即可完成，打开li4.py，在文件开头加入下面一行代码。

```
#从村庄接口服务类中导入借钱服务
from village_interfaces.srv import BorrowMoney
```

### [2.2 创建服务端并定义服务回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_22-创建服务端并定义服务回调函数)

#### [2.2.1创建服务端](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_221创建服务端)

接着创建一个服务，继承于`Node`之后，`WriterNode`也具备了创建一个服务的能力。在`WriterNode`的`__init__`函数中创建成员变量`borrow_server`。

```
# 新建借钱服务
self.borrow_server = self.create_service(BorrowMoney, "borrow_money", self.borrow_money_callback)
```

需要传入三个参数：

- 服务接口类型，`BorrowMoney`，我们在2.1.2导入的

- 服务名称，`"borrow_money"`，具有唯一性，自己手打的

- 回调函数，`self.borrow_money_callback`，我们下一步定义的。

  > 关于回调函数小鱼写过一篇文章：[回调函数与异步执行](https://mp.weixin.qq.com/s/BW18iCGqxlbS3KDF5rp0Aw)，不理解的同学可以看一看

#### [2.2.2 定义回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_222-定义回调函数)

```python
def borrow_money_callback(self,request, response):
    """
    借钱回调函数
    参数：request 客户端请求对象，携带着来自客户端的数据
         response 服务端响应，返回服务端的处理结果
    返回值：response
    """
    return response
```

这个函数有三个入口参数,self代表本身，这个没啥好说的，类似于c++和java里的this。

- request 是客户端请求对象，携带着来自客户端的数据。

  其结构就是上一节中我们所定义的`name`和`money`组成

- response 是服务端响应，返回服务端的处理结果

  其结构由`success`和`money`组成

### [2.3编写回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_23编写回调函数)

接下来开始正式编写回调函数，回调函数的输入是request和response，输出是我们处理后的reponse(当然也可以不处理，使用默认值)

```python
def borrow_money_callback(self,request, response):
    """
    借钱回调函数
    参数：request 客户端请求
         response 服务端响应
    返回值：response
    """
    self.get_logger().info("收到来自: %s 的借钱请求，目前账户内还有%d元" % (request.name, self.account))
    #根据李四借钱规则，借出去的钱不能多于自己所有钱的十分之一，不然就不借
    if request.money <= int(self.account*0.1):
        response.success = True
        response.money = request.money
        self.account = self.account - request.money
        self.get_logger().info("借钱成功，借出%d 元 ,目前账户余额%d 元" % (response.money,self.account))
    else:
        response.success = False
        response.money = 0
        self.get_logger().info("对不起兄弟，手头紧,不能借给你")
    return response
```

这里代码其实并不复杂，先判断要借钱的金额是否满足要借出去的数量，如果满足则借，不然就不借。

为了测试方便，我们为李四的光头账户打赏70块钱，将`__init__`函数中的self.account 默认账户值改为70即可

至此，服务端的代码就编写完成了，完整版代码可以点开[这个网址](https://raw.githubusercontent.com/fishros/ros2_town/master/village_li/village_li/li4.py)查看

## [3.测试服务端代码](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_3测试服务端代码)

### [3.1编译运行](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_31编译运行)

在vscode中，使用`Ctrl+Shift+~`打开一个新的终端，在`town_ws`目录下输入：

```shell
colcon build --packages-select village_li
```

![image-20210816163422495](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210816163422495.png)

### [3.2启动并查看服务列表](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_32启动并查看服务列表)

先`source`，再`run`

```
source install/setup.bash
ros2 run village_li li4_node
```

![image-20210816163704618](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210816163704618.png)

### [3.3手动调用](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_33手动调用)

在VsCode中使用`Ctrl+Shift+5`打开一个切分终端。然后依次输入下面的指令，查看我们的服务。

```
ros2 service list #服务列表
ros2 service list -t #服务列表带类型
```

接着我们使用命令行来手动调用服务，不知道你还是否记得4.7中我们手动调用服务将两个数字相加。

这里我们手动调用服务用李三的名义来借5块钱

```
source install/setup.bash
ros2 service call /borrow_money village_interfaces/srv/BorrowMoney  "{name: 'li3', money: 5}"
```

看返回结果success为True，money的值也变成了5，说明李三借钱成功了。

![image-20210816164314308](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210816164314308.png)

再尝试借50块钱看看李四借不借。

```
ros2 service call /borrow_money village_interfaces/srv/BorrowMoney  "{name: 'li3', money: 50}"
```

这次李四说他手头紧，不给借。返回值中的success也变成了False，money也变成了0。

![image-20210816164511430](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210816164511430.png)

## [4.编写客户端代码](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_4编写客户端代码)

服务端搞定了后，我们来编写客户端李三这边的代码。

编写服务通信的客户端的一般步骤：

1. 导入服务接口
2. 创建请求结果接收回调函数
3. 声明并创建客户端
4. 编写结果接收逻辑
5. 调用客户端发送请求

### [4.1导入服务接口](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_41导入服务接口)

第一步和服务端相同，导入对应的接口，因为李四和李三是在同一个包`village_li`内,所以不需要再次修改`package.xml`。

打开`li3.py`我们直接导入对应接口

```
from village_interfaces.srv import BorrowMoney
```

### [4.2创建请求结果接收回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_42创建请求结果接收回调函数)

编写`borrow_respoonse_callback`借钱结果回调函数，该函数的只有一个入口参数`response`

```
def borrow_respoonse_callback(self,response):
    """
    借钱结果回调
    """
    pass
```

### [4.3创建客户端并定义结果回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_43创建客户端并定义结果回调函数)

李三继承于Node，也具备了创建客户端的能力

```
class BaiPiaoNode(Node): #BaiPiaoNode是继承于Node
```

创建客户端

```
#在__init__函数中创建一个服务的客户端
self.borrow_money_client_ = self.create_client(BorrowMoney, "borrow_money")
```

创建客户端使用函数`create_client`该函数有两个入口参数，一个是服务接口类型，一个是服务名称。

> 这里的两个参数需和服务端的完全一致，方可通信。名字不一致，会找不到对应服务，数据类型不一致会导致无法通信。

### [4.4 编写结果回调函数处理逻辑](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_44-编写结果回调函数处理逻辑)

根据结果说不同的话

```
    def borrow_respoonse_callback(self,response):
        """
        借钱结果回调
        """
        # 打印一下信息
        result = response.result()
        if result.success == True:
            self.get_logger().info("果然是亲弟弟，借到%d,吃麻辣烫去了" % result.money)
        else:
            self.get_logger().info("害，连几块钱都不借,我还是不是他亲哥了，世态炎凉呀")
```

### [4.5 编写发送请求逻辑](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_45-编写发送请求逻辑)

#### [4.5.1创建发送请求函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_451创建发送请求函数)

接着我们在`BaiPiaoNode中`编写一个函数用于创建发送的数据，并发送请求。

```
def borrow_money_eat(self):
    """
    借钱吃麻辣烫函数
    """
    #打印一句话
    self.get_logger().info("找我弟借钱吃麻辣烫喽")
    #等待服务启动，每1s检查一次，如果服务没有启动，则一直循环
    while not self.borrow_money_client_.wait_for_service(1.0):
        self.get_logger().warn("我弟不在线，我再等等。")
    # 构建请求内容
    request = BorrowMoney.Request()
    #将当前节点名称作为借钱者姓名
    request.name = self.get_name()
    #借钱金额10元
    request.money = 10
    #发送异步借钱请求，借钱成功后就调用borrow_respoonse_callback()函数
    self.borrow_money_client_.call_async(request).add_done_callback(self.borrow_respoonse_callback)
```

小鱼来讲一讲这个代码

- `wait_for_service(1.0)`用于等待服务上线，这是一种很优雅的做法，调用之前检测一下服务是否在线
- `call_async(request).add_done_callback`这里是代码的核心部分，用于发送请求，并且添加了一个任务完成时的回调函数`borrow_respoonse_callback`

#### [4.5.2修改main函数调用发送请求函数](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_452修改main函数调用发送请求函数)

因为发送请求的函数是BaiPiaoNode的成员函数，所以我们直接调用BaiPiaoNode来发送请求即可，可以将main函数做如下修改（其实只增加了一行代码而已）。

```
def main(args=None):
    """
    ros2运行该节点的入口函数，可配置函数名称
    """
    rclpy.init(args=args) # 初始化rclpy
    node = BaiPiaoNode()  # 新建一个节点
    node.borrow_money_eat() #增加一行，李三借钱
    rclpy.spin(node) # 保持节点运行，检测是否收到退出指令（Ctrl+C）  
    rclpy.shutdown() # rcl关闭
```

编写好客户端之后，我们就可以做整体的测试了，但要记得编译程序哦。完整的li3.py代码可以[访问这里](https://raw.githubusercontent.com/fishros/ros2_town/master/village_li/village_li/li3.py)获取

> 除了使用`call_async(request)`异步调用，还有一种同步调用的方式，但小鱼并不推荐，原因这里小鱼`mark@鱼香ROS`一下，后面在公众号中单独写一篇文章介绍。

## [5.整体测试](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_5整体测试)

嘀嘀嘀，终于可以开始最终的测试了。

### [5.1编译功能包](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_51编译功能包)

在vscode中，使用`Ctrl+Shift+~`打开一个新的终端，在`town_ws`目录下输入：

```shell
colcon build --packages-select village_li
```

![image-20210816163422495](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210816163422495.png)

### [5.2运行客户端李三程序](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_52运行客户端李三程序)

#### [5.2.1 source](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_521-source)

```
source install/setup.bash
```

#### [5.2.2 运行客户端代码](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_522-运行客户端代码)

```
ros2 run village_li li3_node
```

![image-20210817104713043](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210817104713043.png)

### [5.3运行服务端代码](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_53运行服务端代码)

#### [5.3.1 切分终端并source](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_531-切分终端并source)

vscode中使用`Ctrl+Shift+5`重新切分出一个终端，然后source

```
source install/setup.bash
```

#### [5.3.2 运行服务端李四程序](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_532-运行服务端李四程序)

```
ros2 run village_li li4_node
```

#### [5.3.3 运行结果](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_533-运行结果)

![image-20210817105329996](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210817105329996.png)

从图片中可以看到，李三借钱失败了，原因80*0.1=8<10，不能借给李三十块钱，符合李四做人原则，那为了李三能够吃上麻辣烫，我们可以帮助李四赚钱——让王二过来进行知识付费。

### [5.4运行王二过来知识付费](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_54运行王二过来知识付费)

同样的再切分出一个终端，然后source运行王二节点。

```
source install/setup.bash
ros2 run village_wang wang2_node 
```

重新运行李三节点，点击李三运行的终端，先输入`Ctrl+C`使其退出，再重新运行节点。

```
ros2 run village_li li3_node
```

![image-20210817110416711](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210817110416711.png)

可以看到，此时李四账户里已经有了六百多块了，很轻松的借给了李三10块钱，这多亏了王二的知识付费。

## [6.结束](https://fishros.com/d2lros2foxy/#/chapt4/4.9服务实现(Python)?id=_6结束)

至此，我们帮助李三成功借钱，吃上了麻辣烫，下一步就是编写C++程序，努力帮助张三看上二手书。

如果还有不明白的地方，欢迎加入鱼群交流。

# [4.5.3 C++服务通信实现(张三买书)](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_453-c服务通信实现张三买书)

看到张三买书就突然想起`华强买瓜`，但张三是真心买书不是存心找茬。开始编写代码之前，我们先梳理一下买书任务流程。

## [1.任务流程](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_1任务流程)

**一句话：张三拿多少钱钱给王二，王二凑够多少个章节的艳娘传奇给他**

## [2.服务端（王二）实现](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_2服务端（王二）实现)

首先是作为二手书提供者的服务端王二节点代码的编写。

### [2.1 创建C++服务通信服务端的步骤](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_21-创建c服务通信服务端的步骤)

1. 导入服务接口
2. 创建服务端回调函数
3. 声明并创建服务端
4. 编写回调函数逻辑处理请求

### [2.2 添加服务接口与依赖](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_22-添加服务接口与依赖)

#### [2.2.1 添加依赖](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_221-添加依赖)

> 添加依赖是为了让程序能够在编译和运行时找到对应的接口

因为`village_wang`的包类型是`ament_cmake`，故需要进行以下两步操作：

**第一步修改`package.xml`**

加入下面的代码（告诉colcon，编译之前要确保有village_interfaces存在）

```xml
  <depend>village_interfaces</depend>
```

![image-20210816153438400](https://fishros.com/d2lros2foxy/chapt4/4.9服务实现(Python)/imgs/image-20210816153438400.png)

**第二步修改和`CMakeLists.txt`**

在`CMakeLists.txt`中加入下面一行代码

```cmake
find_package(village_interfaces REQUIRED)
```

> find_package是cmake的语法，用于查找库。找到后，还需要将其和可执行文件链接起来

所以还需要修改`ament_target_dependencies`，在其中添加`village_interfaces`。

```cmake
ament_target_dependencies(wang2_node 
  rclcpp 
  village_interfaces
)
```

#### [2.2.2 添加服务接口](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_222-添加服务接口)

对于C++来说，添加服务接口只需在程序中引入对应的头文件即可。

> 这个头文件就是我们`SellNovel.srv`生成的头文件

```c++
#include "village_interfaces/srv/sell_novel.hpp"
```

### [2.3 声明回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_23-声明回调函数)

#### [2.3.1 声明回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_231-声明回调函数)

添加完服务接口接着就可以声明一个**卖书请求回调函数**。

```c++
// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据
void sell_book_callback(const village_interfaces::srv::SellNovel::Request::SharedPtr request,
        const village_interfaces::srv::SellNovel::Response::SharedPtr response)
{
}
```

#### [2.3.2 存书的队列（可以理解为书库）](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_232-存书的队列（可以理解为书库）)

再创建一个队列，用于存放自己看过的二手书，创建队列需要用到queue容器，所以我们先用`#include <queue>`在程序开头引入该容器，再在代码中添加下面这句话。

```c++
//创建一个小说章节队列
std::queue<std::string>  novels_queue;
```

#### [2.3.3 死锁](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_233-死锁)

当张三请求王二买二手书的时候，假如王二手里书的数量不足，王二就等攒够了对应数量的书再返回给张三。

等待攒够章节的操作需要在`卖书服务函数`中阻塞当前线程，阻塞后王二就收不到李四写的小说了，这样一来就会造成一个很尴尬的情景：

**在卖书服务回调函数中等着书库（队列）里小说章节数量满足张三需求，接收小说的程序等着这边的卖书回调函数结束，好把书放进书库（队列）里。**

这种互相等待的情况，我们称之为死锁。那如何解决呢？

#### [2.3.4 多线程](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_234-多线程)

大家可能会问，为啥接收小说的程序不能自己单独干，非要等待服务回调函数结束才把书放到书库，不能收到书就把书直接放到书库吗？

原因是ROS2默认是单线程的，同时只有一个线程在跑，大家都是顺序执行，你干完我干，一条线下去。

所以为了解决这个问题，我们可以使用多线程，即每次收到服务请求后，单独开一个线程来处理，不影响其他部分。

#### [2.3.5 回调函数组](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_235-回调函数组)

ROS2中要使用多线程执行器和回调组来实现多线程，我们先在`SingleDogNode`中声明一个回调组成员变量。

```c++
// 声明一个服务回调组
rclcpp::CallbackGroup::SharedPtr callback_group_service_;
```

完成 声明之后，我们的`SingleDogNode`新增内容如下：

#### [2.3.6 最终结果](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_236-最终结果)

```c++
class SingleDogNode : public rclcpp::Node 
{

public:
    // 构造函数
    SingleDogNode(std::string name) : Node(name)
    {
    }
    
private:
    // 声明一个服务回调组
    rclcpp::CallbackGroup::SharedPtr callback_group_service_;
    //创建一个小说章节队列
    std::queue<std::string>  novels_queue;
    // 声明一个服务端
    rclcpp::Service<village_interfaces::srv::SellNovel>::SharedPtr server_;
    // 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据
    void sell_book_callback(const village_interfaces::srv::SellNovel::Request::SharedPtr request,
        const village_interfaces::srv::SellNovel::Response::SharedPtr response)
    {
        //对请求数据进行处理
    }
};
```

### [2.4 实例化服务端并编写回调函数处理请求](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_24-实例化服务端并编写回调函数处理请求)

#### [2.4.1 实例化回调组](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_241-实例化回调组)

在`ROS2`中，回调函数组也是一个对象，通过实例化`create_callback_group`类即可创建一个callback_group_service的对象。

在SingleDogNode的构造函数中添加下面这行代码，即可完成实例化

```
callback_group_service_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
```

#### [2.4.2 声明并实例化服务端](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_242-声明并实例化服务端)

我们使用成员函数作为回调函数，这里要根据回调函数中参数个数，设置占位符，即告诉编译器，这个函数需要传入的参数个数。

> 在之前订阅话题的回调函数中，我们已经用到过一次了，因为话题回调只有一个参数，所以只需要一个占位符，这里服务的回调是两个参数，所以要设置两个

```c++
using std::placeholders::_1;
using std::placeholders::_2;
```

在`private:`下**声明服务端**

```
// 声明一个服务端
rclcpp::Service<village_interfaces::srv::SellNovel>::SharedPtr server_;
```

在构造函数中**实例化服务端**

```C++
// 实例化卖二手书的服务
server_ = this->create_service<village_interfaces::srv::SellNovel>("sell_novel",
                            std::bind(&SingleDogNode::sell_book_callback,this,_1,_2),
                            rmw_qos_profile_services_default,
                            callback_group_service_);
```

实例化服务端可以直接使用`create_service`函数，该函数是一个模版函数，需要输入要创建的服务类型，这里我们使用的是`<village_interfaces::srv::SellNovel>`，这个函数有四个参数需要输入,小鱼接下来进行一一介绍

- `"sell_novel"`服务名称，没啥好说的，要唯一哦，因为服务只能有一个
- `std::bind(&SingleDogNode::sell_book_callback,this,_1,_2)`回调函数，这里指向了我们2.3.1中我们声明的`sell_book_callback`
- `rmw_qos_profile_services_default` 通信质量，这里使用服务默认的通信质量
- `callback_group_service_`，回调组，我们前面创建回调组就是在这里使用的，告诉ROS2，当你要调用回调函数处理请求时，请把它放到单独线程的回调组中

#### [2.4.4  编写回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_244-编写回调函数)

现在我们开始编写回调函数，这里属于重点部分。先把整个代码放一下。

```c++
    // 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据
    void sell_book_callback(const village_interfaces::srv::SellNovel::Request::SharedPtr request,
        const village_interfaces::srv::SellNovel::Response::SharedPtr response)
    {
        RCLCPP_INFO(this->get_logger(), "收到一个买书请求，一共给了%d钱",request->money);
        unsigned int novelsNum = request->money*1;  //应给小说数量，一块钱一章

        //判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数
        if(novels_queue.size()<novelsNum)
        {
            RCLCPP_INFO(this->get_logger(), "当前艳娘传奇章节存量为%d：不能满足需求,开始等待",novels_queue.size());

            // 设置rate周期为1s，代表1s检查一次
            rclcpp::Rate loop_rate(1);

            //当书库里小说数量小于请求数量时一直循环
            while (novels_queue.size()<novelsNum)
            {
                //判断系统是否还在运行
                if(!rclcpp::ok())
                {
                    RCLCPP_ERROR(this->get_logger(), "程序被终止了");
                    return ;
                }
                //打印一下当前的章节数量和缺少的数量
                RCLCPP_INFO(this->get_logger(), "等待中，目前已有%d章，还差%d章",novels_queue.size(),novelsNum-novels_queue.size());

                //rate.sleep()让整个循环1s运行一次
                loop_rate.sleep();
            }
        }
        // 章节数量满足需求了
        RCLCPP_INFO(this->get_logger(), "当前艳娘传奇章节存量为%d：已经满足需求",novels_queue.size());

        //一本本把书取出来，放进请求响应对象response中
        for(unsigned int i =0 ;i<novelsNum;i++)
        {
            response->novels.push_back(novels_queue.front());
            novels_queue.pop();
        }
    }
```

当收到请求时，先计算一下应该给张三多少书`novelsNum`，然后判断书库里书的数量够不够，不够则进入攒书程序。如果够或者攒够了就把书放到服务响应对象里，返回给张三。

你可能有一些疑问，我们并没有写把书放进书库（队列`novels_queue`）的程序呀，是的，这里我们还需要修改一下话题回调函数，增加了一行代码，将小说放到书库里`novels_queue.push(msg->data);`

```
 // 收到话题数据的回调函数
 void topic_callback(const std_msgs::msg::String::SharedPtr msg){
     // 新建一张人民币
     std_msgs::msg::UInt32 money;
     money.data = 10;

    // 发送人民币给李四
    pub_->publish(money);
    RCLCPP_INFO(this->get_logger(), "王二：我收到了：'%s' ，并给了李四：%d 元的稿费", msg->data.c_str(),money.data);

    //将小说放入novels_queue中
    novels_queue.push(msg->data);
};
```

### [2.5 修改`main`函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_25-修改main函数)

因为我们要让整个程序变成多线程的，所以我们要把节点的执行器变成多线程执行器。

修改一下`main`函数，新建一个多线程执行器，添加王二节点并`spin`,完整代码如下：

```
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    /*产生一个Wang2的节点*/
    auto node = std::make_shared<SingleDogNode>("wang2");
    /* 运行节点，并检测退出信号*/
    rclcpp::executors::MultiThreadedExecutor exector;
    exector.add_node(node);
    exector.spin();
    rclcpp::shutdown();
    return 0;
}
```

王二节点完整代码见：[wang2.cpp](https://raw.githubusercontent.com/fishros/ros2_town/af8b29f7b23153d35348ebfcd3b1bc5760c6c5a6/village_wang/src/wang2.cpp)

### [2.6 编译](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_26-编译)

在工作空间下：输入下面的指令

```
colcon build --packages-select village_wang
```

![image-20210825173336167](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210825173336167.png)

### [2.7 运行测试](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_27-运行测试)

#### [2.7.1 source环境](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_271-source环境)

打开vscode终端，输入

```shell
source install/setup.bash
```

#### [2.7.2 运行王二节点](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_272-运行王二节点)

```
ros2 run village_wang wang2_node
```

#### [2.7.3 使用命令行发送买书请求](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_273-使用命令行发送买书请求)

切分一个终端，source

```
source install/setup.bash
```

查看一下服务列表

```
ros2@ubuntu:~/code/town_ws$ ros2 service list -t
/sell_book [village_interfaces/srv/SellNovel]
```

手动发送买书请求

```
ros2 service call /sell_book  village_interfaces/srv/SellNovel "{money: 5}"
```

![image-20210831115903946](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210831115903946.png)

#### [2.7.4 启动李四写书](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_274-启动李四写书)

观察以上结果可以发现，我们并没有买到书，因为王二这里也没有，这时候就需要我们来启动李四节点来写书了。

再切分一个终端出来：

```
source install/setup.bash
```

启动李四写书

```
ros2 run village_li li4_node
```

#### [2.7.5 结果展示](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_275-结果展示)

![image-20210831124712850](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210831124712850.png)

## [3.客户端（张三）实现](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_3客户端（张三）实现)

编写完服务端的程序，接下来我们就可以编写客户端张三了。

### [3.1 编写ROS2服务通信客户端步骤](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_31-编写ros2服务通信客户端步骤)

1. 导入服务接口
2. 创建请求结果接收回调函数
3. 声明并创建客户端
4. 编写结果接收逻辑
5. 调用客户端发送请求

### [3.2 添加服务接口与依赖](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_32-添加服务接口与依赖)

#### [3.2.1 创建客户端节点](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_321-创建客户端节点)

因为张家村和张三之前不存在，这里我们需要新创建出来，命令如下：

打开终端到src文件夹下：

```
ros2 pkg create village_zhang --build-type ament_cmake --dependencies rclcpp
```

然后在`src/village_zhang/src`目录下新建`zhang3.cpp`

完成后目录结构如下：

![image-20210831125824511](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210831125824511.png)

#### [3.2.2 创建客户端节点](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_322-创建客户端节点)

因为张三要找王二请求小说，所以一定依赖通信接口`village_interfaces`

> 添加依赖是为了能够让程序在编译和运行时找到对应的接口

因为`village_zhang`是包类型是`ament_cmake`，与上面一样需要两步操作.

**第一步修改`package.xml`**

加入下面的代码（告诉colcon，编译之前要确保有village_interfaces存在）

```xml
  <depend>village_interfaces</depend>
```

![image-20210831130256663](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210831130256663.png)

**第二步修改和`CMakeLists.txt`**

在`CMakeLists.txt`中加入下面一行代码

```cmake
find_package(village_interfaces REQUIRED)
```

> find_package是cmake的语法，用于查找库。找到后，还需要将其和可执行文件链接起来

接着添加可执行文件

```
add_executable(zhang3_node src/zhang3.cpp)
```

上面找到库之后，将其与可执行文件链接起来，还需要修改`ament_target_dependencies`，在其中添加`rclcpp 和 village_interfaces`。

```cmake
ament_target_dependencies(zhang3_node
  rclcpp 
  village_interfaces
)
```

### [3.3 创建张三节点、服务客户端、请求函数和请求结果回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_33-创建张三节点、服务客户端、请求函数和请求结果回调函数)

#### [3.3.1 创建客户端](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_331-创建客户端)

接着我们就可以编写客户端了，穷光蛋张三也是C++，我们可以参考王二的代码，建立一个C++节点的基本的框架。

```
#include "rclcpp/rclcpp.hpp"
#include "village_interfaces/srv/sell_novel.hpp"

// 提前声明的占位符，留着创建客户端的时候用
using std::placeholders::_1;

/*
    创建一个类节点，名字叫做PoorManNode,继承自Node.
*/
class PoorManNode : public rclcpp::Node
{

public:
    /* 构造函数 */
    PoorManNode(std::string name) : Node(name)
    {
        // 打印一句自我介绍
        RCLCPP_INFO(this->get_logger(), "大家好，我是得了穷病的张三.");
    }
private:
};

/*主函数*/
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    /*产生一个Zhang3的节点*/
    auto node = std::make_shared<PoorManNode>("zhang3");
    /* 运行节点，并检测rclcpp状态*/
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

#### [3.3.2 声明客户端](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_332-声明客户端)

这里只是声明客户端，并指明这个客户端的类型是`village_interfaces::srv::SellNovel`

```
    // 创建一个客户端
    rclcpp::Client<village_interfaces::srv::SellNovel>::SharedPtr client_;
```

#### [3.3.3 创建请求函数和回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_333-创建请求函数和回调函数)

在class里的public下新建两个函数，第一个函数用于买小说，第二个函数用于回调买小说的结果`response`。

```
/*买小说函数*/
    void buy_novel()
    {
        RCLCPP_INFO(this->get_logger(), "买小说去喽");
        
    }
    
    /*接收小说-回调函数*/
    void novels_callback(rclcpp::Client<village_interfaces::srv::SellNovel>::SharedFuture  response)
    {
    
    }
```

完整代码：

```
#include "rclcpp/rclcpp.hpp"
#include "village_interfaces/srv/sell_novel.hpp"

// 提前声明的占位符，留着创建客户端的时候用
using std::placeholders::_1;

/*
    创建一个类节点，名字叫做PoorManNode,继承自Node.
*/
class PoorManNode : public rclcpp::Node
{

public:
    /* 构造函数 */
    PoorManNode() : Node("zhang3")
    {
        // 打印一句自我介绍
        RCLCPP_INFO(this->get_logger(), "大家好，我是得了穷病的张三.");
    }
    
    /*买小说函数*/
    void buy_novel()
    {
        RCLCPP_INFO(this->get_logger(), "买小说去喽");
        
    }
    
    /*接收小说-回调函数*/
    void novels_callback(rclcpp::Client<village_interfaces::srv::SellNovel>::SharedFuture  response)
    {
    
    }
private:
    // 创建一个客户端
    rclcpp::Client<village_interfaces::srv::SellNovel>::SharedPtr client_;
};

/*主函数*/
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    /*产生一个PoorManNode的节点*/
    auto node = std::make_shared<PoorManNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

### [3.4 实例化客户端、编写请求函数和回调函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_34-实例化客户端、编写请求函数和回调函数)

#### [3.4.1 实例化客户端](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_341-实例化客户端)

这个我们很熟悉了，先声明再实例化，在构造函数里加一句话。

```
//实例化客户端
client_ = this->create_client<village_interfaces::srv::SellNovel>("sell_novel");
```

实例化调用自身的`create_client`函数即可，这个函数依然是一个模板函数。

这里实例化的时候也要指明客户端的接口类型，同时指定要请求的服务的名称`sell_novel`.

#### [3.4.2 编写请求函数`buy_novel`](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_342-编写请求函数buy_novel)

编写请求函数`but_novel()`。

整个函数可以分为三个部分：

- 等待服务端上线
- 构造请求数据
- 发送异步请求

```
    void buy_novel()
    {
        RCLCPP_INFO(this->get_logger(), "买小说去喽");
        
        //1.等待服务端上线
        while (!client_->wait_for_service(std::chrono::seconds(1)))
        {
            //等待时检测rclcpp的状态
            if (!rclcpp::ok())
            {
                RCLCPP_ERROR(this->get_logger(), "等待服务的过程中被打断...");
                return;
            }
            RCLCPP_INFO(this->get_logger(), "等待服务端上线中");
        }
        
        //2.构造请求的钱
        auto request = std::make_shared<village_interfaces::srv::SellNovel_Request>();
        //先来五块钱的看看好不好看
        request->money = 5; 
        
        //3.发送异步请求，然后等待返回，返回时调用回调函数
        client_->async_send_request(request,std::bind(&PoorManNode::novels_callback, this, _1));
    };
```

结构还是很清晰的，等待服务端上线的时候我们使用的是`client_->wait_for_service`这个函数，该函数有一个参数是超时时间，小鱼这里设置成1s，如果服务端没有上线则一直等待。

第二部分构造请求的钱，C++还是一如既往的长，这里使用make_shared创建了一个指向`village_interfaces::srv::SellNovel_Request`的指针，并赋值给了requet。可以理解为创建了一个钱袋。

```
 auto request = std::make_shared<village_interfaces::srv::SellNovel_Request>();
```

创建好钱袋（request）之后，我们开始往钱袋里装钱，这里装了5块钱。

```
//先来五块钱的看看好不好看
request->money = 5; 
```

第三步发送请求

这一步我们和Python中一样，发送的是异步请求，并且设置了一个回调函数，意思是当我们请求（买书）成功时，请调用这个回调函数，把结果通过回调函数的参数传递过来。

> 关于回调函数前面提过好几次了，小鱼也在公众号上写了相关的文章，不明白的同学可以前往翻阅。

#### [3.4.3 编写回调函数处理结果](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_343-编写回调函数处理结果)

接着编写回调函数`novels_callback`处理结果，完整的回调函数内容如下，也很简单，获取结果然后遍历结果打印。

> 注意函数的参数并不是`SellNovel`的`Response`对象，而是`SharedFuture`，这个小鱼会写篇文章说一说。这里直接用就行，使用`response`的`get()`获取。

```
    //创建接收到小说的回调函数
    void novels_callback(rclcpp::Client<village_interfaces::srv::SellNovel>::SharedFuture  response)
    {
        auto result = response.get();
        
        RCLCPP_INFO(this->get_logger(), "收到%d章的小说，现在开始按章节开读", result->novels.size());
        
        for(std::string novel:result->novels)
        {
            //打印小说章节内容
            RCLCPP_INFO(this->get_logger(), "%s", novel.c_str());
        }
        
        RCLCPP_INFO(this->get_logger(), "小说读完了，好刺激，写的真不错，好期待下面的章节呀！");
    }
```

#### [3.4.4 修改main函数调用请求函数](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_344-修改main函数调用请求函数)

完成上面的工作之后还需要修改一下main函数来调用一下我们的买小说函数。

```
int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    /*产生一个Zhang3的节点*/
    auto node = std::make_shared<PoorManNode>();
    node->buy_novel();
    /* 运行节点，并检测rclcpp状态*/
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

完成代码参考：[ros2_town/wang2.cpp · fishros](https://github.com/fishros/ros2_town/blob/af8b29f7b23153d35348ebfcd3b1bc5760c6c5a6/village_wang/src/wang2.cpp)

### [3.5 修改CmkeLists.txt并编译](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_35-修改cmkeliststxt并编译)

#### [3.5.1 添加指令](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_351-添加指令)

张三节点之前没有安装过，这里需要在`CMakeLists.txt`加入一个安装指令，将编译好的可执行文件，安装到install目录下。

```
install(TARGETS
  zhang3_node
  DESTINATION lib/${PROJECT_NAME}
)
```

#### [3.5.2 编译](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_352-编译)

```
colcon build --packages-select village_zhang
```

![image-20210901201248290](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210901201248290.png)

## [4.测试](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_4测试)

完成了张三和王二的客户端和服务端的程序后，我们就可以测试啦。

### [4.1运行张三](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_41运行张三)

打开新终端，先source再运行张三

```
source install/setup.bash
ros2 run village_zhang zhang3_node
```

### [4.2 运行王二](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_42-运行王二)

切分终端，source并运行王二

```
source install/setup.bash
ros2 run village_wang wang2_node 
```

### [4.3 运行李四写书](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_43-运行李四写书)

切分终端，source并运行李四

```
source install/setup.bash
ros2 run village_li li4_node
```

### [4.5 结果展示](https://fishros.com/d2lros2foxy/#/chapt4/4.10服务实现(C++)?id=_45-结果展示)

![image-20210901201805844](https://fishros.com/d2lros2foxy/chapt4/4.10服务实现(C++)/imgs/image-20210901201805844.png)